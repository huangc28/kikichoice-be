// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AuthProvider string

const (
	AuthProviderClerk     AuthProvider = "clerk"
	AuthProviderAuthstack AuthProvider = "authstack"
)

func (e *AuthProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuthProvider(s)
	case string:
		*e = AuthProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for AuthProvider: %T", src)
	}
	return nil
}

type NullAuthProvider struct {
	AuthProvider AuthProvider `json:"auth_provider"`
	Valid        bool         `json:"valid"` // Valid is true if AuthProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuthProvider) Scan(value interface{}) error {
	if value == nil {
		ns.AuthProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuthProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuthProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuthProvider), nil
}

type ComparisonOperator string

const (
	ComparisonOperatorGt ComparisonOperator = "gt"
	ComparisonOperatorLt ComparisonOperator = "lt"
	ComparisonOperatorEq ComparisonOperator = "eq"
)

func (e *ComparisonOperator) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ComparisonOperator(s)
	case string:
		*e = ComparisonOperator(s)
	default:
		return fmt.Errorf("unsupported scan type for ComparisonOperator: %T", src)
	}
	return nil
}

type NullComparisonOperator struct {
	ComparisonOperator ComparisonOperator `json:"comparison_operator"`
	Valid              bool               `json:"valid"` // Valid is true if ComparisonOperator is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullComparisonOperator) Scan(value interface{}) error {
	if value == nil {
		ns.ComparisonOperator, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ComparisonOperator.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullComparisonOperator) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ComparisonOperator), nil
}

type DeviceProfileUsageType string

const (
	DeviceProfileUsageTypeSystemDefault DeviceProfileUsageType = "system_default"
	DeviceProfileUsageTypeSite          DeviceProfileUsageType = "site"
)

func (e *DeviceProfileUsageType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DeviceProfileUsageType(s)
	case string:
		*e = DeviceProfileUsageType(s)
	default:
		return fmt.Errorf("unsupported scan type for DeviceProfileUsageType: %T", src)
	}
	return nil
}

type NullDeviceProfileUsageType struct {
	DeviceProfileUsageType DeviceProfileUsageType `json:"device_profile_usage_type"`
	Valid                  bool                   `json:"valid"` // Valid is true if DeviceProfileUsageType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDeviceProfileUsageType) Scan(value interface{}) error {
	if value == nil {
		ns.DeviceProfileUsageType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DeviceProfileUsageType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDeviceProfileUsageType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DeviceProfileUsageType), nil
}

type EntityType string

const (
	EntityTypeSite         EntityType = "site"
	EntityTypeOrganisation EntityType = "organisation"
)

func (e *EntityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EntityType(s)
	case string:
		*e = EntityType(s)
	default:
		return fmt.Errorf("unsupported scan type for EntityType: %T", src)
	}
	return nil
}

type NullEntityType struct {
	EntityType EntityType `json:"entity_type"`
	Valid      bool       `json:"valid"` // Valid is true if EntityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEntityType) Scan(value interface{}) error {
	if value == nil {
		ns.EntityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EntityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEntityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EntityType), nil
}

type ExperimentStatus string

const (
	ExperimentStatusDraft     ExperimentStatus = "draft"
	ExperimentStatusRunning   ExperimentStatus = "running"
	ExperimentStatusCompleted ExperimentStatus = "completed"
	ExperimentStatusStopped   ExperimentStatus = "stopped"
)

func (e *ExperimentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ExperimentStatus(s)
	case string:
		*e = ExperimentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ExperimentStatus: %T", src)
	}
	return nil
}

type NullExperimentStatus struct {
	ExperimentStatus ExperimentStatus `json:"experiment_status"`
	Valid            bool             `json:"valid"` // Valid is true if ExperimentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullExperimentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ExperimentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ExperimentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullExperimentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ExperimentStatus), nil
}

type InvoiceStatus string

const (
	InvoiceStatusDraft         InvoiceStatus = "draft"
	InvoiceStatusOpen          InvoiceStatus = "open"
	InvoiceStatusPaid          InvoiceStatus = "paid"
	InvoiceStatusUncollectible InvoiceStatus = "uncollectible"
	InvoiceStatusVoid          InvoiceStatus = "void"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoice_status"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

type Locale string

const (
	LocaleEnUS   Locale = "en-US"
	LocaleEn     Locale = "en"
	LocaleEnAU   Locale = "en-AU"
	LocaleEnGB   Locale = "en-GB"
	LocaleEnIE   Locale = "en-IE"
	LocaleEnSG   Locale = "en-SG"
	LocaleEnZA   Locale = "en-ZA"
	LocaleEnIN   Locale = "en-IN"
	LocaleArXB   Locale = "ar-XB"
	LocaleAr     Locale = "ar"
	LocaleBg     Locale = "bg"
	LocaleCa     Locale = "ca"
	LocaleCs     Locale = "cs"
	LocaleDa     Locale = "da"
	LocaleDe     Locale = "de"
	LocaleEl     Locale = "el"
	LocaleEnXA   Locale = "en-XA"
	LocaleEnXL   Locale = "en-XL"
	LocaleEs     Locale = "es"
	LocaleEs419  Locale = "es-419"
	LocaleEsAR   Locale = "es-AR"
	LocaleEsBO   Locale = "es-BO"
	LocaleEsBR   Locale = "es-BR"
	LocaleEsBZ   Locale = "es-BZ"
	LocaleEsCL   Locale = "es-CL"
	LocaleEsCO   Locale = "es-CO"
	LocaleEsCR   Locale = "es-CR"
	LocaleEsCU   Locale = "es-CU"
	LocaleEsDO   Locale = "es-DO"
	LocaleEsEC   Locale = "es-EC"
	LocaleEsGT   Locale = "es-GT"
	LocaleEsHN   Locale = "es-HN"
	LocaleEsMX   Locale = "es-MX"
	LocaleEsNI   Locale = "es-NI"
	LocaleEsPA   Locale = "es-PA"
	LocaleEsPE   Locale = "es-PE"
	LocaleEsPR   Locale = "es-PR"
	LocaleEsPY   Locale = "es-PY"
	LocaleEsSV   Locale = "es-SV"
	LocaleEsUS   Locale = "es-US"
	LocaleEsUY   Locale = "es-UY"
	LocaleEsVE   Locale = "es-VE"
	LocaleFi     Locale = "fi"
	LocaleFil    Locale = "fil"
	LocaleFr     Locale = "fr"
	LocaleHe     Locale = "he"
	LocaleHi     Locale = "hi"
	LocaleHr     Locale = "hr"
	LocaleHu     Locale = "hu"
	LocaleGsw    Locale = "gsw"
	LocaleID     Locale = "id"
	LocaleIn     Locale = "in"
	LocaleIt     Locale = "it"
	LocaleIw     Locale = "iw"
	LocaleJa     Locale = "ja"
	LocaleKo     Locale = "ko"
	LocaleLt     Locale = "lt"
	LocaleLv     Locale = "lv"
	LocaleMo     Locale = "mo"
	LocaleNl     Locale = "nl"
	LocaleNb     Locale = "nb"
	LocaleNo     Locale = "no"
	LocalePl     Locale = "pl"
	LocalePt     Locale = "pt"
	LocalePtPT   Locale = "pt-PT"
	LocaleRo     Locale = "ro"
	LocaleRu     Locale = "ru"
	LocaleSk     Locale = "sk"
	LocaleSl     Locale = "sl"
	LocaleSr     Locale = "sr"
	LocaleSrLatn Locale = "sr-Latn"
	LocaleSv     Locale = "sv"
	LocaleTa     Locale = "ta"
	LocaleTe     Locale = "te"
	LocaleTh     Locale = "th"
	LocaleTl     Locale = "tl"
	LocaleTr     Locale = "tr"
	LocaleUk     Locale = "uk"
	LocaleVi     Locale = "vi"
	LocaleZh     Locale = "zh"
	LocaleZhHK   Locale = "zh-HK"
	LocaleZhTW   Locale = "zh-TW"
)

func (e *Locale) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Locale(s)
	case string:
		*e = Locale(s)
	default:
		return fmt.Errorf("unsupported scan type for Locale: %T", src)
	}
	return nil
}

type NullLocale struct {
	Locale Locale `json:"locale"`
	Valid  bool   `json:"valid"` // Valid is true if Locale is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLocale) Scan(value interface{}) error {
	if value == nil {
		ns.Locale, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Locale.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLocale) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Locale), nil
}

type NetworkPreset string

const (
	NetworkPresetGprs      NetworkPreset = "gprs"
	NetworkPresetRegular2g NetworkPreset = "regular2g"
	NetworkPresetGood2g    NetworkPreset = "good2g"
	NetworkPresetRegular3g NetworkPreset = "regular3g"
	NetworkPresetGood3g    NetworkPreset = "good3g"
	NetworkPresetRegular4g NetworkPreset = "regular4g"
	NetworkPresetDsl       NetworkPreset = "dsl"
	NetworkPresetWifi      NetworkPreset = "wifi"
	NetworkPresetCustom    NetworkPreset = "custom"
)

func (e *NetworkPreset) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NetworkPreset(s)
	case string:
		*e = NetworkPreset(s)
	default:
		return fmt.Errorf("unsupported scan type for NetworkPreset: %T", src)
	}
	return nil
}

type NullNetworkPreset struct {
	NetworkPreset NetworkPreset `json:"network_preset"`
	Valid         bool          `json:"valid"` // Valid is true if NetworkPreset is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNetworkPreset) Scan(value interface{}) error {
	if value == nil {
		ns.NetworkPreset, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NetworkPreset.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNetworkPreset) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NetworkPreset), nil
}

type OrganisationRole string

const (
	OrganisationRoleAdmin  OrganisationRole = "admin"
	OrganisationRoleMember OrganisationRole = "member"
)

func (e *OrganisationRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrganisationRole(s)
	case string:
		*e = OrganisationRole(s)
	default:
		return fmt.Errorf("unsupported scan type for OrganisationRole: %T", src)
	}
	return nil
}

type NullOrganisationRole struct {
	OrganisationRole OrganisationRole `json:"organisation_role"`
	Valid            bool             `json:"valid"` // Valid is true if OrganisationRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrganisationRole) Scan(value interface{}) error {
	if value == nil {
		ns.OrganisationRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrganisationRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrganisationRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrganisationRole), nil
}

type RegionProvider string

const (
	RegionProviderAws        RegionProvider = "aws"
	RegionProviderCloudflare RegionProvider = "cloudflare"
	RegionProviderGcp        RegionProvider = "gcp"
)

func (e *RegionProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RegionProvider(s)
	case string:
		*e = RegionProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for RegionProvider: %T", src)
	}
	return nil
}

type NullRegionProvider struct {
	RegionProvider RegionProvider `json:"region_provider"`
	Valid          bool           `json:"valid"` // Valid is true if RegionProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRegionProvider) Scan(value interface{}) error {
	if value == nil {
		ns.RegionProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RegionProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRegionProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RegionProvider), nil
}

type SnapshotGroupTrigger string

const (
	SnapshotGroupTriggerScheduled  SnapshotGroupTrigger = "scheduled"
	SnapshotGroupTriggerExperiment SnapshotGroupTrigger = "experiment"
	SnapshotGroupTriggerManual     SnapshotGroupTrigger = "manual"
)

func (e *SnapshotGroupTrigger) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SnapshotGroupTrigger(s)
	case string:
		*e = SnapshotGroupTrigger(s)
	default:
		return fmt.Errorf("unsupported scan type for SnapshotGroupTrigger: %T", src)
	}
	return nil
}

type NullSnapshotGroupTrigger struct {
	SnapshotGroupTrigger SnapshotGroupTrigger `json:"snapshot_group_trigger"`
	Valid                bool                 `json:"valid"` // Valid is true if SnapshotGroupTrigger is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSnapshotGroupTrigger) Scan(value interface{}) error {
	if value == nil {
		ns.SnapshotGroupTrigger, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SnapshotGroupTrigger.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSnapshotGroupTrigger) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SnapshotGroupTrigger), nil
}

type SnapshotStatus string

const (
	SnapshotStatusPending   SnapshotStatus = "pending"
	SnapshotStatusRunning   SnapshotStatus = "running"
	SnapshotStatusCompleted SnapshotStatus = "completed"
	SnapshotStatusError     SnapshotStatus = "error"
)

func (e *SnapshotStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SnapshotStatus(s)
	case string:
		*e = SnapshotStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SnapshotStatus: %T", src)
	}
	return nil
}

type NullSnapshotStatus struct {
	SnapshotStatus SnapshotStatus `json:"snapshot_status"`
	Valid          bool           `json:"valid"` // Valid is true if SnapshotStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSnapshotStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SnapshotStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SnapshotStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSnapshotStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SnapshotStatus), nil
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive     SubscriptionStatus = "active"
	SubscriptionStatusPastDue    SubscriptionStatus = "past_due"
	SubscriptionStatusCanceled   SubscriptionStatus = "canceled"
	SubscriptionStatusIncomplete SubscriptionStatus = "incomplete"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscription_status"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

type SubscriptionTier string

const (
	SubscriptionTierFree       SubscriptionTier = "free"
	SubscriptionTierPro        SubscriptionTier = "pro"
	SubscriptionTierEnterprise SubscriptionTier = "enterprise"
)

func (e *SubscriptionTier) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionTier(s)
	case string:
		*e = SubscriptionTier(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionTier: %T", src)
	}
	return nil
}

type NullSubscriptionTier struct {
	SubscriptionTier SubscriptionTier `json:"subscription_tier"`
	Valid            bool             `json:"valid"` // Valid is true if SubscriptionTier is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionTier) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionTier, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionTier.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionTier) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionTier), nil
}

type TeamMemberRole string

const (
	TeamMemberRoleAdmin  TeamMemberRole = "admin"
	TeamMemberRoleMember TeamMemberRole = "member"
)

func (e *TeamMemberRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TeamMemberRole(s)
	case string:
		*e = TeamMemberRole(s)
	default:
		return fmt.Errorf("unsupported scan type for TeamMemberRole: %T", src)
	}
	return nil
}

type NullTeamMemberRole struct {
	TeamMemberRole TeamMemberRole `json:"team_member_role"`
	Valid          bool           `json:"valid"` // Valid is true if TeamMemberRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTeamMemberRole) Scan(value interface{}) error {
	if value == nil {
		ns.TeamMemberRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TeamMemberRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTeamMemberRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TeamMemberRole), nil
}

type ThrottlingMethod string

const (
	ThrottlingMethodSimulate ThrottlingMethod = "simulate"
	ThrottlingMethodDevtools ThrottlingMethod = "devtools"
	ThrottlingMethodProvided ThrottlingMethod = "provided"
)

func (e *ThrottlingMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ThrottlingMethod(s)
	case string:
		*e = ThrottlingMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for ThrottlingMethod: %T", src)
	}
	return nil
}

type NullThrottlingMethod struct {
	ThrottlingMethod ThrottlingMethod `json:"throttling_method"`
	Valid            bool             `json:"valid"` // Valid is true if ThrottlingMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullThrottlingMethod) Scan(value interface{}) error {
	if value == nil {
		ns.ThrottlingMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ThrottlingMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullThrottlingMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ThrottlingMethod), nil
}

type UsageType string

const (
	UsageTypeSnapshot UsageType = "snapshot"
	UsageTypeSeat     UsageType = "seat"
	UsageTypeSite     UsageType = "site"
)

func (e *UsageType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsageType(s)
	case string:
		*e = UsageType(s)
	default:
		return fmt.Errorf("unsupported scan type for UsageType: %T", src)
	}
	return nil
}

type NullUsageType struct {
	UsageType UsageType `json:"usage_type"`
	Valid     bool      `json:"valid"` // Valid is true if UsageType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsageType) Scan(value interface{}) error {
	if value == nil {
		ns.UsageType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsageType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsageType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsageType), nil
}

type Budget struct {
	ID                int32              `json:"id"`
	Uuid              string             `json:"uuid"`
	SiteID            int32              `json:"site_id"`
	Name              pgtype.Text        `json:"name"`
	Description       pgtype.Text        `json:"description"`
	Enabled           bool               `json:"enabled"`
	NotifyOnViolation bool               `json:"notify_on_violation"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
}

type BudgetThreshold struct {
	ID         int32                  `json:"id"`
	BudgetID   int32                  `json:"budget_id"`
	BudgetUuid pgtype.Text            `json:"budget_uuid"`
	Metric     pgtype.Text            `json:"metric"`
	Operator   NullComparisonOperator `json:"operator"`
	Value      pgtype.Float8          `json:"value"`
	CreatedAt  pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz     `json:"updated_at"`
}

type CpuThrottlingProfile struct {
	ID int32 `json:"id"`
	// Unique id for the CPU throttling profile, for example: low-end-device, mid-range-device...
	Uuid                  string             `json:"uuid"`
	CpuSlowdownMultiplier pgtype.Numeric     `json:"cpu_slowdown_multiplier"`
	Description           string             `json:"description"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	Name                  pgtype.Text        `json:"name"`
}

type Device struct {
	ID int32 `json:"id"`
	// Unique id for the device, for example: chrome-desktop, iphone-12...
	Uuid              string             `json:"uuid"`
	Title             string             `json:"title"`
	Type              string             `json:"type"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	UserAgent         pgtype.Text        `json:"user_agent"`
	Width             pgtype.Int4        `json:"width"`
	Height            pgtype.Int4        `json:"height"`
	DeviceScaleFactor pgtype.Numeric     `json:"device_scale_factor"`
	Mobile            bool               `json:"mobile"`
	Name              pgtype.Text        `json:"name"`
}

type DeviceProfile struct {
	ID                      int32                  `json:"id"`
	Uuid                    string                 `json:"uuid"`
	Name                    pgtype.Text            `json:"name"`
	CreatedAt               pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz     `json:"updated_at"`
	DeviceID                pgtype.Int4            `json:"device_id"`
	ThrottlingProfilesID    pgtype.Int4            `json:"throttling_profiles_id"`
	CpuThrottlingProfilesID pgtype.Int4            `json:"cpu_throttling_profiles_id"`
	UsageType               DeviceProfileUsageType `json:"usage_type"`
	// List of locales that are supported by Lighthouse, e.g., en-GB, en-US, etc.
	Locale    Locale             `json:"locale"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type DeviceProfileEntity struct {
	DeviceProfileID int32              `json:"device_profile_id"`
	EntityID        int32              `json:"entity_id"`
	EntityType      EntityType         `json:"entity_type"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type OrgAggregate struct {
	OrgID     int32  `json:"org_id"`
	Slug      string `json:"slug"`
	TeamCount int64  `json:"team_count"`
}

type Organisation struct {
	ID             int32              `json:"id"`
	Slug           string             `json:"slug"`
	Name           string             `json:"name"`
	Settings       []byte             `json:"settings"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	Uuid           string             `json:"uuid"`
	AuthProviderID string             `json:"auth_provider_id"`
	AuthProvider   AuthProvider       `json:"auth_provider"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	LastSyncedAt   pgtype.Timestamp   `json:"last_synced_at"`
	LastSyncedBy   pgtype.Text        `json:"last_synced_by"`
}

type OrganisationMember struct {
	ID             int32              `json:"id"`
	OrganisationID int32              `json:"organisation_id"`
	UserID         int32              `json:"user_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	Role           OrganisationRole   `json:"role"`
}

type Page struct {
	ID     int32  `json:"id"`
	Uuid   string `json:"uuid"`
	SiteID int32  `json:"site_id"`
	// The relative URL of the page, e.g., /path/to/page
	Url       pgtype.Text        `json:"url"`
	Name      pgtype.Text        `json:"name"`
	Enabled   bool               `json:"enabled"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type Region struct {
	ID        int32              `json:"id"`
	Uuid      string             `json:"uuid"`
	Name      string             `json:"name"`
	Provider  RegionProvider     `json:"provider"`
	Location  pgtype.Text        `json:"location"`
	Enabled   bool               `json:"enabled"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Site struct {
	ID                int32              `json:"id"`
	Slug              string             `json:"slug"`
	TeamID            int32              `json:"team_id"`
	Name              string             `json:"name"`
	Url               pgtype.Text        `json:"url"`
	Description       pgtype.Text        `json:"description"`
	Icon              pgtype.Text        `json:"icon"`
	IsPublic          bool               `json:"is_public"`
	MonitoringEnabled bool               `json:"monitoring_enabled"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	Uuid              string             `json:"uuid"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	OrgID             int32              `json:"org_id"`
}

type SiteSetting struct {
	ID                int32              `json:"id"`
	SiteID            int32              `json:"site_id"`
	Schedule          pgtype.Text        `json:"schedule"`
	Regions           []string           `json:"regions"`
	DeviceProfiles    []string           `json:"device_profiles"`
	NotificationEmail pgtype.Text        `json:"notification_email"`
	NotificationSlack pgtype.Text        `json:"notification_slack"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
}

type SiteTeamView struct {
	ID          int32       `json:"id"`
	Uuid        string      `json:"uuid"`
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	Description pgtype.Text `json:"description"`
	TeamUuid    string      `json:"team_uuid"`
	TeamName    string      `json:"team_name"`
	TeamSlug    string      `json:"team_slug"`
}

type Snapshot struct {
	ID              int32              `json:"id"`
	Uuid            string             `json:"uuid"`
	GroupID         int32              `json:"group_id"`
	SiteID          int32              `json:"site_id"`
	PageID          int32              `json:"page_id"`
	DeviceProfileID int32              `json:"device_profile_id"`
	RegionID        int32              `json:"region_id"`
	Status          SnapshotStatus     `json:"status"`
	Error           pgtype.Text        `json:"error"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	// Storage path to the full report for the snapshot, we use s3 at the moment
	FullReportPath       pgtype.Text        `json:"full_report_path"`
	DeletedAt            pgtype.Timestamptz `json:"deleted_at"`
	SiteSerialID         pgtype.Int4        `json:"site_serial_id"`
	IngestableReportPath pgtype.Text        `json:"ingestable_report_path"`
}

type SnapshotGroup struct {
	ID          int32                `json:"id"`
	Uuid        string               `json:"uuid"`
	SiteID      int32                `json:"site_id"`
	Trigger     SnapshotGroupTrigger `json:"trigger"`
	Status      SnapshotStatus       `json:"status"`
	StartedAt   pgtype.Timestamptz   `json:"started_at"`
	CompletedAt pgtype.Timestamptz   `json:"completed_at"`
	CreatedAt   pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz   `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz   `json:"deleted_at"`
}

type Team struct {
	ID               int32              `json:"id"`
	Slug             string             `json:"slug"`
	Name             string             `json:"name"`
	Description      pgtype.Text        `json:"description"`
	AvatarUrl        pgtype.Text        `json:"avatar_url"`
	OrganisationID   int32              `json:"organisation_id"`
	OrgSlug          pgtype.Text        `json:"org_slug"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	Uuid             string             `json:"uuid"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	OrganisationUuid pgtype.Text        `json:"organisation_uuid"`
}

type TeamAggregate struct {
	TeamID         int32  `json:"team_id"`
	OrganisationID int32  `json:"organisation_id"`
	Slug           string `json:"slug"`
	SiteCount      int64  `json:"site_count"`
	MemberCount    int64  `json:"member_count"`
}

type TeamMember struct {
	ID     int32 `json:"id"`
	TeamID int32 `json:"team_id"`
	// Role of the user in the team
	Role      TeamMemberRole     `json:"role"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	UserID    int32              `json:"user_id"`
}

type TeamMemberAggregate struct {
	Role           TeamMemberRole `json:"role"`
	TeamID         int32          `json:"team_id"`
	UserID         int32          `json:"user_id"`
	FirstName      pgtype.Text    `json:"first_name"`
	LastName       pgtype.Text    `json:"last_name"`
	Email          string         `json:"email"`
	AuthProviderID string         `json:"auth_provider_id"`
}

type ThrottlingProfile struct {
	ID int32 `json:"id"`
	// Unique id for the throttling profile, for example: regular-2g, slow-3g...
	Uuid                    string             `json:"uuid"`
	LatencyMs               int32              `json:"latency_ms"`
	DownloadKbps            pgtype.Numeric     `json:"download_kbps"`
	UploadKbps              pgtype.Numeric     `json:"upload_kbps"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	Method                  ThrottlingMethod   `json:"method"`
	NetworkThrottlingPreset NullNetworkPreset  `json:"network_throttling_preset"`
	Name                    pgtype.Text        `json:"name"`
}

type User struct {
	ID        int32       `json:"id"`
	Uuid      string      `json:"uuid"`
	Email     string      `json:"email"`
	FirstName pgtype.Text `json:"first_name"`
	LastName  pgtype.Text `json:"last_name"`
	// UUID for authentication vendor provider that we use, e.g., Clerk, Authstack, etc.
	AuthProviderID      string             `json:"auth_provider_id"`
	AuthProvider        AuthProvider       `json:"auth_provider"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	AuthProviderOptCode pgtype.Text        `json:"auth_provider_opt_code"`
	LastSyncedAt        pgtype.Timestamp   `json:"last_synced_at"`
	LastSyncedBy        pgtype.Text        `json:"last_synced_by"`
}
