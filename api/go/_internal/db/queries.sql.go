// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products
  (sku, name, price, category, stock_count, description)
VALUES
  ($1, $2, $3, $4, $5, $6)
RETURNING id, uuid, sku, name, price, original_price, category, in_stock, stock_count, specs, description, full_description, is_active, sort_order, created_at, updated_at
`

type CreateProductParams struct {
	Sku         string         `json:"sku"`
	Name        string         `json:"name"`
	Price       pgtype.Numeric `json:"price"`
	Category    string         `json:"category"`
	StockCount  int32          `json:"stock_count"`
	Description pgtype.Text    `json:"description"`
}

// Product queries
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Sku,
		arg.Name,
		arg.Price,
		arg.Category,
		arg.StockCount,
		arg.Description,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Sku,
		&i.Name,
		&i.Price,
		&i.OriginalPrice,
		&i.Category,
		&i.InStock,
		&i.StockCount,
		&i.Specs,
		&i.Description,
		&i.FullDescription,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductImage = `-- name: CreateProductImage :one
INSERT INTO product_images
  (product_id, url, alt_text, is_primary, sort_order)
VALUES
  ($1, $2, $3, $4, $5)
RETURNING id, product_id, url, alt_text, is_primary, sort_order, created_at, updated_at
`

type CreateProductImageParams struct {
	ProductID int64       `json:"product_id"`
	Url       string      `json:"url"`
	AltText   pgtype.Text `json:"alt_text"`
	IsPrimary bool        `json:"is_primary"`
	SortOrder pgtype.Int4 `json:"sort_order"`
}

func (q *Queries) CreateProductImage(ctx context.Context, arg CreateProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, createProductImage,
		arg.ProductID,
		arg.Url,
		arg.AltText,
		arg.IsPrimary,
		arg.SortOrder,
	)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Url,
		&i.AltText,
		&i.IsPrimary,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductSpec = `-- name: CreateProductSpec :one
INSERT INTO product_specs
  (product_id, spec_name, spec_value, sort_order)
VALUES
  ($1, $2, $3, $4)
RETURNING id, product_id, spec_name, spec_value, sort_order, created_at, updated_at
`

type CreateProductSpecParams struct {
	ProductID int64       `json:"product_id"`
	SpecName  string      `json:"spec_name"`
	SpecValue string      `json:"spec_value"`
	SortOrder pgtype.Int4 `json:"sort_order"`
}

func (q *Queries) CreateProductSpec(ctx context.Context, arg CreateProductSpecParams) (ProductSpec, error) {
	row := q.db.QueryRow(ctx, createProductSpec,
		arg.ProductID,
		arg.SpecName,
		arg.SpecValue,
		arg.SortOrder,
	)
	var i ProductSpec
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.SpecName,
		&i.SpecValue,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users
  (name, email)
VALUES
  ($1, $2)
RETURNING id, name, email, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySKU = `-- name: GetProductBySKU :one
SELECT id, uuid, sku, name, price, original_price, category, in_stock, stock_count, specs, description, full_description, is_active, sort_order, created_at, updated_at
FROM products
WHERE sku = $1 AND is_active = true
LIMIT 1
`

func (q *Queries) GetProductBySKU(ctx context.Context, sku string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySKU, sku)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Sku,
		&i.Name,
		&i.Price,
		&i.OriginalPrice,
		&i.Category,
		&i.InStock,
		&i.StockCount,
		&i.Specs,
		&i.Description,
		&i.FullDescription,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductImages = `-- name: GetProductImages :many
SELECT id, product_id, url, alt_text, is_primary, sort_order, created_at, updated_at
FROM product_images
WHERE product_id = $1
ORDER BY sort_order
`

func (q *Queries) GetProductImages(ctx context.Context, productID int64) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, getProductImages, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Url,
			&i.AltText,
			&i.IsPrimary,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSpecs = `-- name: GetProductSpecs :many
SELECT id, product_id, spec_name, spec_value, sort_order, created_at, updated_at
FROM product_specs
WHERE product_id = $1
ORDER BY sort_order
`

func (q *Queries) GetProductSpecs(ctx context.Context, productID int64) ([]ProductSpec, error) {
	rows, err := q.db.Query(ctx, getProductSpecs, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductSpec
	for rows.Next() {
		var i ProductSpec
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.SpecName,
			&i.SpecValue,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, name, email, created_at, updated_at, deleted_at
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, created_at, updated_at, deleted_at
FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
